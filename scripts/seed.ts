import path from "path";
import dotenv from "dotenv";
dotenv.config({ path: path.resolve(__dirname, "../.env.local") });

async function ensureProduct(prisma: any, name: string, sku: string, cost: number, stock: number, minStockLevel = 0) {
  const existing = await prisma.product.findUnique({ where: { sku } });
  if (existing) return existing.id as string;

  const created = await prisma.product.create({
    data: { name, sku, cost, min_stock_level: minStockLevel, current_stock: stock },
    select: { id: true }
  });
  return created.id as string;
}

async function createOperation(
  prisma: any,
  type: "INCOMING" | "OUTGOING" | "INTERNAL" | "ADJUSTMENT",
  partner: string,
  scheduleDate: Date,
  source: string,
  dest: string,
  status: "DRAFT" | "WAITING" | "READY" | "DONE" | "CANCELED",
  items: Array<{ product_id: string; qty: number; done_qty?: number }>
) {
  // Create operation
  const op = await prisma.operation.create({
    data: { 
      type, 
      partner, 
      schedule_date: scheduleDate, 
      source_location: source, 
      destination_location: dest, 
      status,
      reference: null // Will be auto-generated by database
    },
    select: { id: true, reference: true }
  });
  
  const operationId = op.id as string;

  // Create operation items
  if (items.length > 0) {
    const itemsData = items.map(i => ({
      operation_id: operationId,
      product_id: i.product_id,
      qty: i.qty,
      done_qty: i.done_qty ?? 0
    }));
    
    await prisma.operationItem.createMany({
      data: itemsData
    });
  }

  // If DONE, create stock moves and update product stock
  if (status === "DONE") {
    for (const i of items) {
      const moveQty = i.done_qty ?? i.qty;
      
      // Create stock move
      await prisma.stockMove.create({
        data: {
          date: new Date(),
          product_id: i.product_id,
          qty: moveQty,
          from_location: source,
          to_location: dest,
          reference_doc: op.reference || '',
          status: "DONE"
        }
      });
      
      // Adjust stock based on type
      const product = await prisma.product.findUnique({
        where: { id: i.product_id }
      });
      
      if (product) {
        const current = product.current_stock ?? 0;
        let newStock = current;
        
        if (type === "INCOMING") {
          newStock = current + moveQty;
        } else if (type === "OUTGOING") {
          newStock = current - moveQty;
        } else if (type === "ADJUSTMENT") {
          // For adjustments, we're setting the stock to a specific value
          newStock = moveQty;
        }
        
        // Ensure stock doesn't go negative
        newStock = Math.max(0, newStock);
        
        await prisma.product.update({
          where: { id: i.product_id },
          data: { current_stock: newStock }
        });
      }
    }
  }

  return op;
}

async function run() {
  console.log("Seeding StockMaster demo data...");

  // Import Prisma client
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();

  try {
    const deskId = await ensureProduct(prisma, "[DESK001] Desk", "DESK001", 3000, 50, 5);
    const tableId = await ensureProduct(prisma, "[TABLE001] Table", "TABLE001", 1000, 45, 5);

    // 1) Done Receipt (WH/IN/0001) from Vendor to WH/Stock1 containing 10 Desks
    await createOperation(
      prisma,
      "INCOMING",
      "Vendor",
      new Date(),
      "Vendor",
      "WH/Stock1",
      "DONE",
      [{ product_id: deskId, qty: 10, done_qty: 10 }]
    );

    // 2) Ready Delivery (WH/OUT/0001) to Azure Interior for 2 Desks
    await createOperation(
      prisma,
      "OUTGOING",
      "Azure Interior",
      new Date(),
      "WH/Stock1",
      "Customer",
      "READY",
      [{ product_id: deskId, qty: 2 }]
    );

    // 3) Draft Delivery (WH/OUT/0002) to Azure Interior
    await createOperation(
      prisma,
      "OUTGOING",
      "Azure Interior",
      new Date(),
      "WH/Stock1",
      "Customer",
      "DRAFT",
      []
    );

    console.log("Seed complete.");
  } finally {
    await prisma.$disconnect();
  }
}

run().catch((err) => {
  console.error("Seed failed:", err);
  process.exit(1);
});